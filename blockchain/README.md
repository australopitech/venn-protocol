# rWallet documentation

This SC wallet works in accordance with [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337). This means it uses bundlers and an entryPoint to send execution calls to each wallet contract. The call requests are handled by the app. Below you can see a high-level overview of how the protocol works on-chain.
## Contents
- [Architecture]()
	- [Factory]()
	- [Wallet]()
	- [Market Place]()
- [Compatibility ]()
	- [NFTs]()
	- [Market Places]()
- [Adresses]()
- [Tutorials]()

----
## Architecture

The protocol is composed by three main entities: the *factory*, the *wallet* and the *market place*. The **factory** is a smart contract that handles wallet creation and it is called every time a user opens a new account. The **wallet** is also a contract that is deployed by the factory when a new account should be created. The wallet implementation is stored by the factory contract and every wallet has the same implementation. The **market place** is also a smart contract that handles specific types of transaction involving wallet contracts, namely **NFT rental transactions**. To enable a fully functioning protocol all three types of contracts need to communicate with each other.

[imagem flow]
### Factory
[Contract code]()

The *Factory* is a singleton contract that is called every time a new account is created. It stores the wallet contract implementation and handles the deployment of each single instance of wallet used in the protocol. This is done via `createAccount` method.

The contract also stores every wallet address created by it so external addresses can check if a given address is a wallet_name or not. This can be done via `isWallet` method.
#### Entry Point
The *Entry Point* contract is also a singleton and it handles every call request made by bundlers. This means that in effect every `execute` call received by wallets should be done by the Entry Point. The contract code can be found [here](link).

### Wallet
[Contract code]()

The *Wallet* contract is the implementation that each account generated by the factory uses. In theory it is also a singleton deployed by the factory in its `constructor` upon its own deployment. Each new account is a `ERC1967Proxy` pattern that uses the singleton as its `implementation`. However, in a high-level analysis we can abstract that away and treat each new account as its own implementation. So that is what we gonna do here.

The two main methods present in wallet implementations are `execute` and `pullAsset`. The `execute` method is supposed to execute any type of transaction requested by the app via entryPoint. That means transfers, deposits, stakes or any other external (or internal) call are handled by `execute`.

```
function execute(address dest, uint256 value, bytes calldata func) external
```

Each time `execute` is called it checks the calldata to see if the transaction should be authorized. So far, unauthorized transactions include the following types for ERC721 (you can see the signature here):
- transfers, 
- approvals, 
- operator settings (*approveForAll*).
The first two types are blocked for NFT's being rented by the wallet. The third is blocked for contracts in which the wallet has rented at least one NFT.

Apart from the cases cited above, the wallet functions like any other wallet. That means users can transfer and approve any asset held as long as its not a rental; and set operators as long as there aren't any tokens from the target contract rented by the wallet.

In effect, NFT's rented by users are "stuck" in the wallet until the rent is due.

`pullAsset` enables external contracts to pull rented tokens back to the original owner after the rental period expires. That mean that the method checks for the current timestamp before making the transfer. The target address of the transfer is always the address who held the NFT when rent was made.

```
function pullAsset(uint256 index) external
```

The asset is identified by a internal index (`index`) stored inside the wallet contract. This index can be accessed via the view function below:

```
function getTokenIndex(address contract_, uint256 tokenId) external view returns(uint256)
```

### Market Place
[Contract code]()

The *Market Place* role is to be an intermediary between account who want to put their NFTs for rent, and wallet_name users who want to rent these NFTs. Any Market Place can make itself compatible with our protocol. To see how checkout [next section](link).  

We provide our own implementation of a Market Place, provided via the dapp. Third parties can use it as a reference but that's not the only way to do it. The code can be seen [here](link). Let's see how it works:

The main methods use in the contract are `listNFT`, `rentNFT` and `deList`. The first one allows any type of account to list an NFT by passing its identification (contract and id) and the listing metadata (price and max duration). 

```
function listNFT(
	address contract_, uint256 tokenId, uint256 price, uint256 maxDuration
) external
```

It requires the caller be the owner of the token and the Market Place contract be approved or set as an operator. Since we are using a deposit format the NFT is transferred to the Market Place contract. That means that after the listing the token is no longer in custody of the lister. To allow more freedom to listers, Market Place issues an NFT-receipt that can be used as a guarantee of ownership of the token in question. It tracks the original NFT's metadata, so it looks like an exact replica except it is issued from a different contract. 

The receipt-NFT can be sold or used as collateral just like a normal NFT, except that it may not hold some innate functionality held by the original NFT. We propose a solution to this: NFT issuers can allow receipts to hold functionality by checking its provenance ([here](link)), and checking if the NFT was rented or not. As long as the NFT is not rented, only the receipt can be used in place of the original. When the NFT is indeed rented, the receipt should be blocked from functionality to guarantee only one of them can be used. *(We will go into more detail on how to do this the future)*

After listing the NFT, listers can change listing metadata by calling `setPrice` and `setMaxDuration`. These methods are restricted to the current owner of the NFT-receipt. That means that if the original lister sells or deposit the receipt it can no longer access these methods. Listers need to be wary of contracts in which they deposit their NFT-receipts. The holder of the receipt at any moment is in effect treated as the lister, so when the rent is due this holder can claim the original asset for themselves. On the other hand, this also means that the receipt-NFT holds value as a claim to the original asset in the future, and can be sold to interested parties.

The second main method `rentNFT` is restricted to wallet_name accounts. It also requires that the account has no operators set for the contract from which the NFT was issued (check out the [next session](link) to see how this is done). 

```solidity
function rentNFT (
        address contract_, uint256 tokenId, uint256 duration
    ) external payable override
```

It receives as inputs the NFT identification (contract address and id) and the duration of the rent, that has to be less than or equal to the specified `maxDuration`. `maxDuration` can be accessed via the `getMaxDuration` view function. This function is defined by `IMarketPlace` interface, as explained in the next session.

The third method, `deList`, as its name suggests, should be called when the lister wants to de-list a listed NFT. It's restricted to the current owner of the related NFT-receipt. There are 3 possible scenarios, regarding the rental, in which the method can be called. In each of them the method is gonna behave in a different manner:

- **1st scenario**: the listed NFT is available, i.e, it is no being rented at the moment of the call.
--> In this case the method is gonna reset the listing metadata and transfer the NFT back to the caller burning the related NFT-receipt.

- **2nd scenario**: the listed NFT is rented out and the rent period has not yet expired.
--> In this scenario, the method resets the listing metadata, making the NFT unavailable for future rents.

- **3rd scenario**: the listed NFT is rented out and the rent period has expired.
--> The listing metadata is also reset to zero, and the NFT is pulled back from the wallet_name account and sent to the caller's address. In this case the caller absorbs the **pull fee** (*explained below).

There is one more public method important make this contract fully functioning. If you noticed in the 2nd scenario above, the NFT is delisted making it ineligible for future rents, but it is not retrieved from the wallet. In this scenario when the rent is finally due another action is required to make the retrieval.

To enable this there is a method called `pullAsset`. This method is actually called by `deList` in the 3rd scenario. This method is permissionless and pays a cut from the service fee the caller, the **pull fee**. This provides a profit opportunity for any *searcher* account monitoring the protocol and contributes for a better user experience. The pull fee related to every NFT is easily accessible via `getPullFee`. Of course even if the searchers do not provide this service the very user can always call the method himself.

----
## Compatibility
To be fully compatible with our protocol, third party contracts need to follow a small set of requirements.
### NFTs
Wallets are compatible with any contract that implements `IERC721`. Our Market Place supports contracts that use `IERCMetadata` or `ERC721URIStorage`.
### Market Places
As mentioned in the previous section, any Market Place easily can make itself compatible with our protocol. All it needs to do is implement the `IMarketPlace` interface shown bellow and follow a few requirements.

```solidity
interface IMarketPlace {

    function rentNFT (address contract_, uint256 tokenId, uint256 duration) external payable;
    
}
```

*Words MUST, REQUIRE, SHOULD in accordance [RFC-2119](https://www.rfc-editor.org/rfc/rfc2119.txt)*.
#### Requirements
Implementations MUST:
- implement `IMarketPlace` and use `rentNFT` as its main method (outer most function) to execute rent transactions.
- REQUIRE callers ARE wallet_name accounts ([click here](link) to see how).
- REQUIRE caller's *operator count* for the NFT contract to be ZERO ([click here]() for instructions).
#### Prescriptions
Implementations SHOULD:
- REQUIRE `duration` is less then or equal to maximum duration specified by NFT owner.
- REQUIRE `msg.value` be enough to cover the rent value and any outstanding service fee.
----
## Adresses
We are currently in testing phase and not available for end users. As soon we launch the relevant contract addresses are gonna be listed here. The below addresses can be found on the listed testnets.
### Base Goerli
- Factory: [0x470459A74DD5ace425A7bd52c537847DaDeF7F91](https://goerli.basescan.org/address/0x470459a74dd5ace425a7bd52c537847dadef7f91) 
- Entry Point: [0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789](https://goerli.basescan.org/address/0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789) (Stackup)
- Wallet Implementation: [0x2B40823eA22C8342414aD27a2d25043EF32DF5Aa](https://goerli.basescan.org/address/0x2b40823ea22c8342414ad27a2d25043ef32df5aa)
- Market Place: [0xD2cB0110eF568f90d974DDf233090dEe67cdcd60](https://goerli.basescan.org/address/0xd2cb0110ef568f90d974ddf233090dee67cdcd60)
- Receipts: [0xd8049548906a53bc2a8431bd671e1e3f36790b76](https://goerli.basescan.org/address/0xd8049548906a53bc2a8431bd671e1e3f36790b76)

----

## Guides

### How to run the POC

### How to be compatible
